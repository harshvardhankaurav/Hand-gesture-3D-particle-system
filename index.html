<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>Advanced Gesture Particle System</title>
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<style>
  body { margin:0; overflow:hidden; background:black; }
  video { display:none; }
</style>

<script src="https://unpkg.com/three@0.158.0/build/three.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js"></script>
<script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js"></script>
</head>

<body>
<video id="video" autoplay playsinline></video>

<script>
/* ===============================
   PARTICLE SHAPES
================================ */

const COUNT = 2200;

function heart() {
  return Array.from({length:COUNT}, () => {
    const t = Math.random()*Math.PI*2;
    return new THREE.Vector3(
      16*Math.pow(Math.sin(t),3),
      13*Math.cos(t)-5*Math.cos(2*t)-2*Math.cos(3*t)-Math.cos(4*t),
      (Math.random()-0.5)*6
    );
  });
}

function flower() {
  return Array.from({length:COUNT}, () => {
    const a = Math.random()*Math.PI*2;
    const r = Math.sin(6*a)*10;
    return new THREE.Vector3(
      Math.cos(a)*r,
      Math.sin(a)*r,
      (Math.random()-0.5)*5
    );
  });
}

function saturn() {
  return Array.from({length:COUNT}, () => {
    const a = Math.random()*Math.PI*2;
    const r = 10+Math.random()*6;
    return new THREE.Vector3(
      Math.cos(a)*r,
      (Math.random()-0.5)*2,
      Math.sin(a)*r
    );
  });
}

function fireworks() {
  return Array.from({length:COUNT}, () =>
    new THREE.Vector3(
      Math.random()-0.5,
      Math.random()-0.5,
      Math.random()-0.5
    ).normalize().multiplyScalar(Math.random()*15)
  );
}

const SHAPES = [heart, flower, saturn, fireworks];

/* ===============================
   THREE.JS SETUP
================================ */

const scene = new THREE.Scene();
const camera = new THREE.PerspectiveCamera(60, innerWidth/innerHeight, 0.1, 1000);
camera.position.z = 50;

const renderer = new THREE.WebGLRenderer({ antialias:true });
renderer.setSize(innerWidth, innerHeight);
document.body.appendChild(renderer.domElement);

const geometry = new THREE.BufferGeometry();
const positions = new Float32Array(COUNT*3);
const targetPositions = new Float32Array(COUNT*3);
const colors = new Float32Array(COUNT*3);

geometry.setAttribute("position", new THREE.BufferAttribute(positions,3));
geometry.setAttribute("color", new THREE.BufferAttribute(colors,3));

const material = new THREE.PointsMaterial({
  size:0.5,
  vertexColors:true,
  transparent:true,
  opacity:0.9
});

const particles = new THREE.Points(geometry, material);
scene.add(particles);

/* ===============================
   MORPHING
================================ */

let currentShape = 0;

function morphToShape(idx) {
  SHAPES[idx]().forEach((p,i)=>{
    targetPositions.set([p.x,p.y,p.z], i*3);
  });
}

function updateMorph() {
  const pos = geometry.attributes.position.array;
  for (let i=0;i<pos.length;i++) {
    pos[i] += (targetPositions[i]-pos[i]) * 0.08;
  }
  geometry.attributes.position.needsUpdate = true;
}

morphToShape(currentShape);

/* ===============================
   HAND TRACKING
================================ */

let scaleFactor = 1;
let rotTarget = 0;
let lastPinch = false;
let pinchHold = 0;

const hands = new Hands({
  locateFile:f=>`https://cdn.jsdelivr.net/npm/@mediapipe/hands/${f}`
});

hands.setOptions({
  maxNumHands: 2,
  modelComplexity: 0,
  minDetectionConfidence: 0.6,
  minTrackingConfidence: 0.6
});

hands.onResults(res => {
  if (!res.multiHandLandmarks.length) return;

  /* ===== ONE HAND ===== */
  const h1 = res.multiHandLandmarks[0];
  const palm1 = h1[0];
  const thumb = h1[4];
  const index = h1[8];

  const pinch = Math.hypot(thumb.x-index.x, thumb.y-index.y);
  const PINCH_ON = 0.07;
  const PINCH_OFF = 0.11;

  if (pinch < PINCH_ON && !lastPinch) {
    currentShape = (currentShape+1)%SHAPES.length;
    morphToShape(currentShape);
    lastPinch = true;
  }
  if (pinch < PINCH_ON) pinchHold++;
  else pinchHold = 0;

  if (pinchHold > 25) morphToShape(3);
  if (pinch > PINCH_OFF) lastPinch = false;

  /* ===== POSITION ===== */
  let x = palm1.x, y = palm1.y, z = palm1.z;

  /* ===== TWO HAND CONTROL ===== */
  if (res.multiHandLandmarks.length === 2) {
    const h2 = res.multiHandLandmarks[1][0];
    x = (palm1.x + h2.x) / 2;
    y = (palm1.y + h2.y) / 2;

    const dist = Math.hypot(palm1.x-h2.x, palm1.y-h2.y);
    scaleFactor = THREE.MathUtils.clamp(dist * 6, 0.8, 3.5);
  } else {
    scaleFactor = THREE.MathUtils.clamp(1.2 + (-z * 4), 0.7, 3);
  }

  particles.position.x += (((x-0.5)*30)-particles.position.x)*0.25;
  particles.position.y += ((-(y-0.5)*30)-particles.position.y)*0.25;

  /* ===== ROTATION ===== */
  rotTarget = (x-0.5)*Math.PI;

  /* ===== COLOR ===== */
  const c = THREE.MathUtils.clamp(0.5 - z*3, 0, 1);
  const col = geometry.attributes.color;
  for (let i=0;i<col.count;i++) {
    col.setXYZ(i, c, 0.3+(1-c)*0.7, 1);
  }
  col.needsUpdate = true;
});

new Camera(document.getElementById("video"), {
  onFrame: async()=>hands.send({image:video}),
  width:640,
  height:480
}).start();

/* ===============================
   ANIMATE
================================ */

function animate() {
  requestAnimationFrame(animate);

  updateMorph();

  particles.rotation.y += (rotTarget-particles.rotation.y)*0.08;
  particles.scale.setScalar(scaleFactor);

  renderer.render(scene,camera);
}

animate();

addEventListener("resize",()=>{
  camera.aspect = innerWidth/innerHeight;
  camera.updateProjectionMatrix();
  renderer.setSize(innerWidth,innerHeight);
});
</script>
</body>
</html>
